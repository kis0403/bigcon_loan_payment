################################################
#################### E D A #####################
################################################

### 데이터 불러오기 

origin_data = read.csv('/home/snu/Bigcontest/challenge_data/Data_set.csv',fileEncoding='euc-kr',stringsAsFactors = TRUE)
origin_data <- origin_data[origin_data$BNK_LNIF_CNT+origin_data$CPT_LNIF_CNT+origin_data$SPART_LNIF_CNT+origin_data$ECT_LNIF_CNT!=0,] # 대출 합계가 0인 행삭제
preresult <- read.csv('/home/snu/Bigcontest/challenge_data/sunday.csv',stringsAsFactors = TRUE)
### 데이터 종류별 분할

sci_data <- origin_data[,c(2,3:16)]
in_data <- origin_data[,c(1,2,53,54,17:52)]
ph_data <- origin_data[,c(1,2,53,54,55:69)]

### SCI_DATA EDA
print(colnames(sci_data))

## BNK_LNIF_CNT
BNK_LNIF_CNT <- sci_data$BNK_LNIF_CNT
table(sci_data$BNK_LNIF_CNT)
plot(prop.table(table(sci_data$BNK_LNIF_CNT)),t="l")
# 1일 0.5의 비율로 가장많고 1부터 커질 때 마다 비율이 줄어듬.

plot(prop.table(table(sci_data$BNK_LNIF_CNT[sci_data$TARGET==1])),t="l")
plot(prop.table(table(sci_data$BNK_LNIF_CNT[sci_data$TARGET==0])),t="l")
prop.table(table(sci_data$BNK_LNIF_CNT==0,sci_data$TARGET),1)
prop.table(table(sci_data$BNK_LNIF_CNT<=1,sci_data$TARGET),1)

# TARGET==1 일 때는 전체와 다르게 0일 때 약 0.6에 가까운 값을 나타냄



#CPT_LNIF_CNT
CPT_LNIF_CNT <- sci_data$CPT_LNIF_CNT
table(CPT_LNIF_CNT)
plot(prop.table(table(CPT_LNIF_CNT)),t="l")

# 1일 0.5의 비율로 가장많고 1부터 커질 때 마다 비율이 줄어듬.
plot(prop.table(table(CPT_LNIF_CNT[sci_data$TARGET==1])),t="l") # TARGET==1일 때 0인 비율이 낮다
plot(prop.table(table(CPT_LNIF_CNT[sci_data$TARGET==0])),t="l")




# SPART_LNIF_CNT
SPART_LNIF_CNT <- sci_data$SPART_LNIF_CNT
plot(prop.table(table(SPART_LNIF_CNT)),t="l")
plot(prop.table(table(SPART_LNIF_CNT[sci_data$TARGET==1])),t="l")
plot(prop.table(table(SPART_LNIF_CNT[sci_data$TARGET==0])),t="l")

# ECT_LNIF_CNT
ECT_LNIF_CNT <- sci_data$ECT_LNIF_CNT
plot(prop.table(table(ECT_LNIF_CNT)),t="l")
plot(prop.table(table(ECT_LNIF_CNT[sci_data$TARGET==1])),t="l")
plot(prop.table(table(ECT_LNIF_CNT[sci_data$TARGET==0])),t="l")

# ALL_CNT

# TOT_LNIF_AMT
TOT_LNIF_AMT <- ifelse(sci_data$TOT_LNIF_AMT==0,0,sci_data$TOT_LNIF_AMT+3000)/1000
hist(TOT_LNIF_AMT[sci_data$TARGET==1])
hist(TOT_LNIF_AMT[sci_data$TARGET==0])

TOT_LNIF_AMT_nom <- log(TOT_LNIF_AMT)
hist(TOT_LNIF_AMT_nom[sci_data$TARGET==1])
hist(TOT_LNIF_AMT_nom[sci_data$TARGET==0])
sci_data$TOT_LNIF_AMT <- TOT_LNIF_AMT_nom
data_set$TOT_LNIF_AMT <- TOT_LNIF_AMT_nom

# TOT_LNIF_AMT / ALL_CNT
ratio_LNIF <- TOT_LNIF_AMT/(BNK_LNIF_CNT+CPT_LNIF_CNT+SPART_LNIF_CNT+ECT_LNIF_CNT)
log_ratio_LNIF <- log(ratio_LNIF)

# TOT_CLIF_AMT
TOT_CLIF_AMT <- ifelse(sci_data$TOT_CLIF_AMT==0,0,sci_data$TOT_CLIF_AMT+3000)/1000
hist(TOT_LNIF_AMT)
hist(TOT_LNIF_AMT[sci_data$TARGET==1],probability = TRUE,breaks = 1000)
hist(TOT_LNIF_AMT[sci_data$TARGET==0],probability = TRUE,breaks=1000)

TOT_CLIF_AMT_nom <- log(TOT_CLIF_AMT+1)
hist(TOT_CLIF_AMT_nom[sci_data$TARGET==1],probability = TRUE,breaks=1000)
hist(TOT_CLIF_AMT_nom[sci_data$TARGET==0],probability = TRUE,breaks=1000)
sci_data$TOT_CLIF_AMT <- TOT_CLIF_AMT_nom
data_set$TOT_CLIF_AMT <- TOT_CLIF_AMT_nom
#CLIF_TOT
CLIF <- TOT_CLIF_AMT/TOT_LNIF_AMT
hist(CLIF[sci_data$TARGET==1])
hist(CLIF[sci_data$TARGET==0])
sci_data$CLIF <- CLIF

## BNK_LNIF_AMT
BNK_LNIF_AMT <- ifelse(sci_data$BNK_LNIF_AMT==0,0,sci_data$BNK_LNIF_AMT+3000)
# 단위를 1000으로 바꾼다.
BNK_LNIF_AMT <- round(BNK_LNIF_AMT/1000)
hist(BNK_LNIF_AMT) 
# 0인데이터가 대부분이고 값이 클 수록 Frequency가 줄어듬을 알 수 있다.
hist(BNK_LNIF_AMT[sci_data$TARGET==1]) # TARGET==1일 때 0인 비율이 더 높다
hist(BNK_LNIF_AMT[sci_data$TARGET==0]) 

# log를 취하면 0을 제외하고는 정규분포가 된다. (좋을지는 모르겠음)
BNK_LNIF_AMT_nom <- log(BNK_LNIF_AMT+1)
hist(BNK_LNIF_AMT_nom)
hist(BNK_LNIF_AMT_nom[sci_data$TARGET==1])
hist(BNK_LNIF_AMT_nom[sci_data$TARGET==0])
sci_data$BNK_LNIF_AMT <- BNK_LNIF_AMT_nom
data_set$BNK_LNIF_AMT <- BNK_LNIF_AMT_nom
# BNK_TOT
BNK <- BNK_LNIF_AMT/TOT_LNIF_AMT

hist(BNK[sci_data$TARGET==1])
hist(BNK[sci_data$TARGET==0])
sci_data$BNK <- BNK

# CPT_LNIF_AMT
CPT_LNIF_AMT <- ifelse(sci_data$CPT_LNIF_AMT==0,0,sci_data$CPT_LNIF_AMT+3000)
plot(table(CPT_LNIF_AMT))
plot(table(CPT_LNIF_AMT[sci_data$TARGET==1])) 
plot(table(CPT_LNIF_AMT[sci_data$TARGET==0]) )

CPT_LNIF_AMT_nom <- log(CPT_LNIF_AMT+1)
hist(CPT_LNIF_AMT_nom)
hist(CPT_LNIF_AMT_nom[sci_data$TARGET==1])
hist(CPT_LNIF_AMT_nom[sci_data$TARGET==0])

sci_data$CPT_LNIF_AMT <- CPT_LNIF_AMT_nom
data_set$CPT_LNIF_AMT <- CPT_LNIF_AMT_nom
# CRDT_OCCR_MDIF
CRDT_OCCR_MDIF <- sci_data$CRDT_OCCR_MDIF

hist(CRDT_OCCR_MDIF,probability = TRUE)
hist(CRDT_OCCR_MDIF[sci_data$TARGET==1],probability = TRUE)
hist(CRDT_OCCR_MDIF[sci_data$TARGET==0],probability = TRUE)


# SPTCT_OCCR_MDIF
SPTCT_OCCR_MDIF <- sci_data$SPTCT_OCCR_MDIF
hist(SPTCT_OCCR_MDIF[sci_data$TARGET==1],probability = TRUE)
hist(SPTCT_OCCR_MDIF[sci_data$TARGET==0],probability = TRUE)


# CRDT_CARD_CNT
CRDT_CARD_CNT <- sci_data$CRDT_CARD_CNT

hist(CRDT_CARD_CNT)
hist(CRDT_CARD_CNT[sci_data$TARGET==1],breaks=10,probability=TRUE)
hist(CRDT_CARD_CNT[sci_data$TARGET==0],breaks=10,probability=TRUE) # CRDT_CARD_CNT

# CTCD_OCCR_MDIF
CTCD_OCCR_MDIF <- sci_data$CTCD_OCCR_MDIF
hist(CTCD_OCCR_MDIF)
hist(CTCD_OCCR_MDIF[sci_data$TARGET==1],breaks=10,probability=TRUE)
hist(CTCD_OCCR_MDIF[sci_data$TARGET==0],breaks=10,probability=TRUE) #CTCD가 0일 떄 효과적

prop.table(table(CRDT_CARD_CNT==0 & CTCD_OCCR_MDIF==0 , sci_data$TARGET),1)


# factor
sci_data$BNK_LNIF_CNT <- as.factor(BNK_LNIF_CNT)
sci_data$CRDT_CARD_CNT <- as.factor(CRDT_CARD_CNT)
sci_data$CRDT_OCCR_MDIF <- as.factor(CRDT_OCCR_MDIF)
sci_data$SPART_LNIF_CNT <- as.factor(SPART_LNIF_CNT)

##$!#$!@#$#
## data 생성#######
data_set = read.csv('/home/snu/Bigcontest/challenge_data/Data_set.csv',fileEncoding='euc-kr',stringsAsFactors = TRUE)
#data_set <- test
# 전처리 파트#
data_set <- data_set[data_set$BNK_LNIF_CNT+data_set$CPT_LNIF_CNT+data_set$SPART_LNIF_CNT+data_set$ECT_LNIF_CNT!=0,] # 대출 합계가 0인 행삭제

# 카드 CRDT_CARD_CNT_cat # 
data_set$CRDT_CARD_CNT <- ifelse(data_set$CRDT_CARD_CNT>6,6,data_set$CRDT_CARD_CNT)
data_set$CRDT_CARD_CNT <- as.factor(data_set$CRDT_CARD_CNT)
prop.table(table(data_set$CRDT_CARD_CNT,data_set$TARGET),1)

# 연체율 숫자로 #
#data_set$LT1Y_PEOD_RATE <- as.numeric(substr(data_set$LT1Y_PEOD_RATE,1,2))

# ratio_LNIF는 전체 금액을 전체 건수로 나눈 비율
data_set$ratio_LNIF =data_set$TOT_LNIF_AMT/(data_set$BNK_LNIF_CNT+data_set$CPT_LNIF_CNT+data_set$SPART_LNIF_CNT+data_set$ECT_LNIF_CNT)
######################################################################

# 대출급액 대비 소득
level <- unique(data_set$OCCP_NAME_G)

# 직업별로 표준화 (한게 좋은지 안한게 좋은지 판단하기)
for(i in 1:length(level)){
  job <- level[i]
  if(sd(data_set$CUST_JOB_INCM[data_set$OCCP_NAME_G==job])!=0){
    data_set$CUST_JOB_INCM[data_set$OCCP_NAME_G==job] <- (data_set$CUST_JOB_INCM[data_set$OCCP_NAME_G==job]-mean(data_set$CUST_JOB_INCM[data_set$OCCP_NAME_G==job]))/sd(data_set$CUST_JOB_INCM[data_set$OCCP_NAME_G==job])
  }
}

cor(data_set$CUST_JOB_INCM,data_set$TARGET)

# 아내직업별 표준화
level <- unique(data_set$MATE_OCCP_NAME_G)
# 직업별로 표준화 (한게 좋은지 안한게 좋은지 판단하기)
for(i in 1:length(level)){
  job <- level[i]
  if(sd(data_set$MATE_JOB_INCM[data_set$MATE_OCCP_NAME_G==job])!=0){
    data_set$MATE_JOB_INCM[data_set$MATE_OCCP_NAME_G==job] <- (data_set$MATE_JOB_INCM[data_set$MATE_OCCP_NAME_G==job]-mean(data_set$MATE_JOB_INCM[data_set$MATE_OCCP_NAME_G==job]))/sd(data_set$MATE_JOB_INCM[data_set$MATE_OCCP_NAME_G==job])
  }
}

###가족수
b <- data_set$CUST_FMLY_NUM
prop.table(table(b,data_set$TARGET),1)
table(b,data_set$TARGET)

# 가족소득
# 가구별로 표준화
level <- unique(data_set$CUST_FMLY_NUM)
data_set$HSHD_INFR_INCM <- data_set$HSHD_INFR_INCM/data_set$TOT_LNIF_AMT

#가구수별 표준화
for(i in 1:length(level)){
  fnum <- level[i]
  a <- data_set$HSHD_INFR_INCM[data_set$CUST_FMLY_NUM==fnum]/fnum
  b <- (a-mean(a))/sd(a)
  data_set$HSHD_INFR_INCM[data_set$CUSTL_FMLY_NUM==fnum] <- b
}


#CRDT_OCCR_MDIF & SPTCT_OCCR_MDIF
sp <- data_set$SPTCT_OCCR_MDIF
table(sp,data_set$TARGET)
cr <- data_set$CRDT_OCCR_MDIF
table(cr,data_set$TARGET)
data_set$CR_SP_MDIF <- as.factor(ifelse(cr>sp,1,ifelse(cr==0&sp==0,2,ifelse(cr==sp,3,4))))

#SPTCT_OCCR_MDIF
table(data_set$TOT_CLIF_AMT==0,data_set$CR_SP_MDIF==2)
table(data_set$TOT_CLIF_AMT==0,data_set$TARGET)

#신용대출 금액/전체금액
a <- data_set$TOT_CLIF_AMT/data_set$TOT_LNIF_AMT
data_set$ratio_CLIF_TOT_AMT <- a

#은행대출 금액/전체금액
a <- data_set$BNK_LNIF_AMT/data_set$TOT_LNIF_AMT
data_set$ratio_BNK_TOT_AMT <- a

#카드사할부사 / 전체금액
a <- data_set$CPT_LNIF_AMT/data_set$TOT_LNIF_AMT
data_set$ratio_CPT_TOT_AMT <- a

# 은행대출금액/은행대출건수
data_set$ratio_BNK <- data_set$BNK_LNIF_AMT/(1+data_set$BNK_LNIF_CNT)

#카드사 캐피탈사/건수
data_set$ratio_CPT <- data_set$CPT_LNIF_AMT/(1+data_set$CPT_LNIF_CNT)

#대출정보 
a <- data_set$BNK_LNIF_CNT
b <- data_set$CPT_LNIF_CNT
c <- data_set$SPART_LNIF_CNT
d <- data_set$ECT_LNIF_CNT

data_set$Loan <- as.factor(ifelse(b==0&c==0&d==0,1,ifelse(b==0|c==0|d==0,2,3)))

#신용카드
a <- data_set$CTCD_OCCR_MDIF
table(a,data_set$TARGET)
b <- data_set$CRDT_CARD_CNT
table(b,data_set$TARGET)
c <- as.numeric(b)/(a+1)
data_set$per_CARD <- c

#신용대출
a <- data_set$TOT_CLIF_AMT
b <- as.numeric(as.character(data_set$CRDT_CARD_CNT))
c <- a/(b+1)
data_set$per_CLIF <- c


d <- data_set$SPTCT_OCCR_MDIF
e <- a/(d+1)
data_set$per_CLIF_2 <- e


#SPART_ECT
a <- data_set$TOT_LNIF_AMT
b <- data_set$BNK_LNIF_AMT
c <- data_set$CPT_LNIF_AMT
d <- a-b-c
data_set$TOT_SP_EC <- d
data_set$per_SP_EC <- d/(data_set$SPART_LNIF_CNT+data_set$ECT_LNIF_CNT+1)
data_set$per_SP_EC <- ifelse(is.nan(data_set$per_SP_EC),0,data_set$per_SP_EC)
data_set$per_SP_EC <- ifelse(is.infinite(data_set$per_SP_EC),0,data_set$per_SP_EC)

#
data_set$CTCD_OCCR_MDIF <- as.factor(data_set$CTCD_OCCR_MDIF)

#한화생명신용상환금액/한화생명신용대출금액
data_set$TOT_CRLN_ratio<-data_set$TOT_REPY_AMT/data_set$TOT_CRLN_AMT
data_set$TOT_CRLN_ratio <- ifelse(is.nan(data_set$TOT_CRLN_ratio),0,data_set$TOT_CRLN_ratio)


######################################################################
# ratio_CLIF_d_LNIF
data_set$ratio_CLIF_d_LNIF =data_set$TOT_CLIF_AMT/data_set$TOT_LNIF_AMT
######################################################################

######################################################################
# ratio_BNK_d_LNIF
data_set$ratio_BNK_d_LNIF =data_set$BNK_LNIF_AMT/data_set$TOT_LNIF_AMT
######################################################################

######################################################################
# ratio_CPT_d_LNIF
data_set$ratio_CPT_d_LNIF =data_set$CPT_LNIF_AMT/data_set$TOT_LNIF_AMT
######################################################################

######################################################################
# ratio_BNK_d_N
data_set$ratio_BNK_d_N =data_set$BNK_LNIF_AMT/data_set$BNK_LNIF_CNT
data_set$ratio_BNK_d_N = ifelse(is.nan(data_set$ratio_BNK_d_N),0,data_set$ratio_BNK_d_N)
######################################################################

######################################################################
# ratio_CPT_d_N
data_set$ratio_CPT_d_N =data_set$CPT_LNIF_AMT/data_set$CPT_LNIF_CNT
data_set$ratio_CPT_d_N <- ifelse(is.nan(data_set$ratio_CPT_d_N),0,data_set$ratio_CPT_d_N)
######################################################################

######################################################################
# 전체 대출 횟수
data_set$all_loan <- data_set$BNK_LNIF_CNT+data_set$CPT_LNIF_CNT+data_set$SPART_LNIF_CNT+data_set$ECT_LNIF_CNT
######################################################################

######################################################################
# 은행대출 / 전체 대출 횟수
data_set$BNK_d_all_loan <- data_set$BNK_LNIF_CNT/data_set$all_loan
data_set$BNK_d_all_loan <- ifelse(is.nan(data_set$BNK_d_all_loan),0,data_set$BNK_d_all_loan)
######################################################################

######################################################################
# 카드사/할부사/캐피탈 / 전체 대출 횟수
data_set$CPT_d_all_loan <- data_set$CPT_LNIF_CNT/data_set$all_loan
data_set$CPT_d_all_loan <- ifelse(is.nan(data_set$CPT_d_all_loan),0,data_set$CPT_d_all_loan)
######################################################################

######################################################################
# [2산업분류]/ 전체 대출 횟수
data_set$SPART_d_all_loan <- data_set$SPART_LNIF_CNT/data_set$all_loan
data_set$SPART_d_all_loan <- ifelse(is.nan(data_set$SPART_d_all_loan),0,data_set$SPART_d_all_loan)
######################################################################

######################################################################
# 은행, 카드사/할부사/캐피탈 제외 대출금액
data_set$except_loan <-data_set$TOT_LNIF_AMT-data_set$BNK_LNIF_AMT-data_set$CPT_LNIF_AMT
data_set$except_loan <- ifelse(data_set$except_loan<0,0,data_set$except_loan)
######################################################################
# 
# ######################################################################
# # ETC_d_all_loan
# data_set$ETC_d_all_loan <- data_set$ECT_LNIF_CNT/ data_set$all_loan
# ######################################################################
# 
# ######################################################################
# # loan_type
# data_set$loan_type <- data_set$ratio_BNK_d_LNIF
# data_set$loan_type[which(data_set$ratio_BNK_d_LNIF>0.5 &  data_set$ratio_BNK_d_LNIF!=1)] <- 2
# data_set$loan_type[(data_set$ratio_BNK_d_LNIF<=0.5 & data_set$ratio_BNK_d_LNIF!=0)] <- 3
# ######################################################################
# 
# ######################################################################
# # ratio_except_loan_d_LNIF
# data_set$ratio_except_loan_d_LNIF <- data_set$except_loan / data_set$TOT_LNIF_AMT
# ######################################################################
# 
# ######################################################################
# # per_income
# data_set$perincome <- data_set$HSHD_INFR_INCM/data_set$ACTL_FMLY_NUM
# ######################################################################
# 
# 
# 
# ######################################################################
# # ratio_CNT_d_AMT
# data_set$ratio_CNT_d_AMT <- data_set$all_loan / data_set$TOT_LNIF_AMT



######2017.09.03 Precision79   -1.50 0.55520254 0.4205776 0.47860322  

i=3
for(i in 1:ncol(data_set)){
  if(is.factor(data_set[,i])){
    len <- as.numeric(data_set[,i])
    data_set[,i] <- as.factor(paste0("a",len))
  }
}


########### 추가 변수 표준화 #####################3
data_set <- data_set[,-which(colnames(data_set)=="TEL_CNTT_QTR")]
normv <- function(data){
  if(sum(data==0)){
    y <- log(data+1)
  }else{
    y <- log(data)
  }
  return(y)
}

#
data_set$CB_GUIF_AMT <- normv(data_set$CB_GUIF_AMT)
#
data_set$MON_TLFE_AMT <- normv(data_set$MON_TLFE_AMT)
#
data_set$MOBL_FATY_PRC <- normv(data_set$MOBL_FATY_PRC)
#
data_set$CRMM_OVDU_AMT <- normv(data_set$CRMM_OVDU_AMT) 
#
data_set$LT1Y_MXOD_AMT <- normv(data_set$LT1Y_MXOD_AMT)
#
data_set$MOBL_PRIN <- normv(data_set$MOBL_PRIN)
#
data_set$ratio_LNIF <- normv(data_set$ratio_LNIF)
#
data_set$ratio_BNK <- normv(data_set$ratio_BNK)
#
data_set$per_CLIF <- normv(data_set$per_CLIF)
#
data_set$per_CLIF_2 <- normv(data_set$per_CLIF_2)
#
#data_set$TOT_SP_EC <- normv(data_set$TOT_SP_EC)
#
data_set$ratio_BNK_d_N <- normv(data_set$ratio_BNK_d_N)
#
data_set$ratio_CPT_d_N <- normv(data_set$ratio_CPT_d_N)
#
data_set$except_loan <- normv(data_set$ratio_CPT_d_N)
#TEL_CNTT_QTR  삭제
str(data_set)
#$!@#$!@#$#
library(h2o)
library(caret)
h2o.init(nthreads = -1)
h2o.no_progress() # Don't show progress bars in RMarkdown output


# data split
intrain<-createDataPartition(y=data_set$TARGET, p=0.7, list=FALSE) 
train<-data_set[intrain,-1]
test<-data_set[-intrain,-1]

train <- as.h2o(train)
test <- as.h2o(test)
# Identify predictors and response
y <- "TARGET"
x <- setdiff(names(train), y)

# For binary classification, response should be a factor
train[,y] <- as.factor(train[,y])
test[,y] <- as.factor(test[,y])

# Number of CV folds (to generate level-one data for stacking)
nfolds <- 5
# Train & Cross-validate a GBM
my_gbm <- h2o.gbm(x = x,
                  y = y,
                  training_frame = train,
                  distribution = "bernoulli",
                  max_depth = 10,
                  stopping_rounds = 5, stopping_tolerance = 1e-4, stopping_metric = "AUC", 
                  min_rows = 2,
                  ntrees = 1000,
                  learn_rate = 0.01,
                  nfolds = nfolds,
                  score_tree_interval = 10,
                  fold_assignment = "Modulo",
                  keep_cross_validation_predictions = TRUE,
                  seed = 7)

pred <- h2o.predict(my_gbm,test)
table(as.data.frame(pred$predict)[,1],data_set$TARGET[-intrain])


# Train & Cross-validate a RF
my_rf <- h2o.randomForest(x = x,
                          y = y,
                          training_frame = train,
                          nfolds = nfolds,
                          fold_assignment = "Modulo",
                          keep_cross_validation_predictions = TRUE,
                          seed = 1)

pred <- h2o.predict(my_rf,test)
table(as.data.frame(pred$predict)[,1],data_set$TARGET[-intrain])

# Train & Cross-validate a DNN
my_dl <- h2o.deeplearning(x = x,
                          y = y,
                          training_frame = train,
                          l1 = 0.001,
                          l2 = 0.001,
                          hidden = c(200, 200, 200),
                          nfolds = nfolds,
                          fold_assignment = "Modulo",
                          keep_cross_validation_predictions = TRUE,
                          seed = 1)
pred <- h2o.predict(my_dl,test)
table(as.data.frame(pred$predict)[,1],data_set$TARGET[-intrain])


# Train & Cross-validate a (shallow) XGB-GBM

# Train a stacked ensemble using the H2O and XGBoost models from above
base_models <- list(my_gbm@model_id,
                    my_rf@model_id,
                    my_dl@model_id,  
                    my_xgb1@model_id,
                    my_xgb2@model_id)

ensemble <- h2o.stackedEnsemble(x = x,
                                y = y,
                                training_frame = train,
                               
                                base_models = base_models)

# Eval ensemble performance on a test set
perf <- h2o.performance(ensemble, newdata = test)
pred <- h2o.predict(ensemble,newdata=test)

# Compare to base learner performance on the test set
get_auc <- function(mm) h2o.auc(h2o.performance(h2o.getModel(mm), newdata = test))
baselearner_aucs <- sapply(base_models, get_auc)
baselearner_best_auc_test <- max(baselearner_aucs)
ensemble_auc_test <- h2o.auc(perf)

print(sprintf("Best Base-learner Test AUC:  %s", baselearner_best_auc_test))
print(sprintf("Ensemble Test AUC:  %s", ensemble_auc_test))


str(pred)
a <- as.data.frame((pred$predict))
pt<- data.frame(table(as.numeric(a$predict),data_set$TARGET[-intrain]))
pt[,3][2]
pt[,3][3]
pt[,3][4]
p <- pt[,3][4]/(pt[,3][2]+pt[,3][4])
r <- pt[,3][4]/(pt[,3][3]+pt[,3][4])
2*p*r/(p+r)

# summary(my_xgb1)
# test <-  read.csv('/home/snu/Bigcontest/challenge_data/Test_set.csv',fileEncoding='euc-kr',stringsAsFactors = TRUE)
# result <- data_set[,c(-1,-2)]
# result <- as.h2o(result)
# pred <- h2o.predict(ensemble,result)
# c <- as.data.frame(pred$predict)
# table(c$predict)
# preresult$today <- c$predict
# cor(as.numeric(preresult$TARGET),as.numeric(preresult$today))
# mean(preresult$TARGET==preresult$today)
# #####################################33
# y="TARGET"
# stack <- h2o.stack(models = base_models,
#                    response_frame = train[,y],
#                    metalearner = metalearner, 
#                    seed = 1,
#                    keep_levelone_data = TRUE)
# ?h2o.stack
# h2o.stackedEnsemble
# # Compute test set performance:
# perf <- h2o.ensemble_performance(stack, newdata = test)
###!$@#$!@#$!#
#
my_xgb1 <- h2o.xgboost(x = x,
                       y = y,
                       training_frame = train,
                       distribution = "bernoulli",
                       ntrees = 100,
                       max_depth = 8,
                       min_rows = 10,
                       learn_rate = 0.01,
                       sample_rate = 0.7,
                       col_sample_rate = 0.8,
                       nfolds = nfolds,
                       fold_assignment = "Modulo",
                       keep_cross_validation_predictions = TRUE,
                       
                       seed = 7)

pred <- h2o.predict(my_xgb1,test)
table(as.data.frame(pred$C1)[,1],data_set$TARGET[-intrain])

my_xgb2 <- h2o.xgboost(x = x,
                       y = y,
                       training_frame = train,
                       distribution = "bernoulli",
                       ntrees = 1000,
                       max_depth = 15,
                       min_rows = 12,
                       learn_rate = 0.005,
                       sample_rate = 0.8,
                       col_sample_rate = 0.9,
                       nfolds = nfolds,
                       fold_assignment = "Modulo",
                       keep_cross_validation_predictions = TRUE,
                       seed = 1)
pred2 <- h2o.predict(my_xgb2,test)
table(as.data.frame(pred2$C1)[,1],data_set$TARGET[-intrain])


####################################################################
####################### G R I D ####################################
###################################################################
hyper_params = list(max_depth = c(4,6,8,12,16),ntrees=c(50,100,200,400),
                    min_child_weight=c(0.5,0.7,1),learn_rate=c(0.1,0.01,0.05),subsample=c(0.6,0.8),
                    col_sample_rate=c(0.6,0.8),max_delta_step=c(0,1,5),gamma=c(0,1),normalize_type=c("forest","tree"),
                    stopping_rounds=c(0,5,10),min_rows=c(6,10,12))
grid <- h2o.grid(
  
  hyper_params = hyper_params,
  search_criteria = list(strategy = "Cartesian"),
  
  algorithm="xgboost",
  grid_id="depth_grid",
  
  x = x, 
  y = y, 
  training_frame = train, 
  validation_frame = test,
  distribution = "bernoulli",
  
  seed = 7,                                                             
  
  stopping_metric = "AUC" ,
  stopping_tolerance = 1e-4,
  
  score_tree_interval = 10                                                
)
